---
title: "I'm Tired of the AI Doom and Gloom — Here's Why I'm Still Excited"
description: "Every time I open LinkedIn or Reddit, someone's declaring the end of software engineering. But the doom narrative misses the point entirely."
pubDate: 2026-02-08
tags: ['ai', 'career', 'tech', 'personal']
draft: false
---

Every time I open LinkedIn lately, I feel like I'm attending a funeral for my own career.

## The noise

It's become a genre. The clickbait screenshots of ChatGPT writing a Python script. The grumbling from senior engineers about how we're automating ourselves into obsolescence. The non-technical hot takes from people who just discovered that computers can output English.

It is exhausting. And honestly, it’s mostly engagement bait.

When you’ve spent a decade mastering a hard skill, watching a machine do it in seconds feels personal. I feel that twinge of vertigo too. But most of the doom narrative isn't analysis; it's just the sound of people reacting to a shifting baseline.

## We do this every decade

In the 1950s, assembly programmers looked down on high-level languages. They insisted that *real* programming meant managing memory addresses, and that using a compiler was cutting corners. They weren't entirely wrong—early compilers were inefficient—but they missed the point. Compilers didn't kill programming. They just raised the abstraction layer.

We did it again with Stack Overflow in 2008. The worry was that copy-pasting answers would create a generation of engineers who couldn't think for themselves. "Nobody learns the fundamentals anymore," we said.

And we did it when GitHub Copilot launched. Immediate panic: *Why learn to code if the robot does it?*

Three years later, junior developers still exist. They just start from a different baseline. The tool eliminates the tedious part—memorizing syntax, typing boilerplate—and the bottleneck moves upstream.

## What actually changed

The difference this time isn't the disruption; it's the speed.

Two years ago, integrating a new API meant reading docs for an hour, writing a boilerplate HTTP client, and handling error cases manually. Today, I paste the docs into an LLM and get a working client in thirty seconds.

The time I save isn't spent idling. It’s spent on the parts that actually matter: the retry logic, the observability, the edge cases where the API fails in weird ways.

Refactoring is different now, too. I can map dependencies and identify patterns across thousands of lines in minutes. But the AI still misses the business logic. It breaks implicit contracts. It doesn't know that *this* specific error message drives support tickets up by 20%.

That context—the messy, human, organizational reality—is still the job.

## Syntax vs. Strategy

Writing glue code is becoming a commodity. Orchestrating workflows, designing systems, and understanding trade-offs is where the value is moving.

That actually excites me.

I like that I can prototype a complex idea in an afternoon instead of a week. It means I can throw away bad ideas faster.
I like that the barrier to entry is dropping. Junior engineers aren't less capable; they're just empowered to build bigger things earlier in their careers.
I like that I spend less time translating English into code and more time questioning whether the requirements make sense.

The parts of engineering that always felt like the "real work"—the design, the judgment, the architecture—are becoming the *whole* work.

## Still here

I’m not blind to the risk. The market is shifting, and roles will compress. But the narrative that software engineering is "over" assumes that our value was typing characters into a text file.

It never was. Our value is solving problems. The tools just got better.
